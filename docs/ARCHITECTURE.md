# Архитектура Dark Weather v2

> Диаграммы находятся в каталоге [`docs/diagrams/`](./diagrams/) и синхронизированы с описанием ниже. Используйте их вместе с текстом.

## Высокоуровневый обзор

Проект организован как модульный монолит, разделённый на доменные модули, которые могут развиваться независимо и при необходимости выделяться в отдельные сервисы. В основе лежит паттерн **Bridge**, позволяющий абстрагировать бизнес-логику от конкретных интеграций (погодные провайдеры, каналы доставки уведомлений, MQTT-шина и т.д.).

- **Core** — реализует доменные сущности, агрегаты и сценарии использования. Здесь находятся API кейсы, связанные с прогнозом погоды, аналитикой и рекомендациями.
- **Integration Layer** — адаптеры для внешних сервисов: провайдеры погоды (Yandex Weather, Open-Meteo и др.), OpenRouter для генерации подсказок, MQTT-брокер и др.
- **Interface Layer** — Django REST API, административная панель Core Manager и WebSocket шлюзы. Для клиентов предусмотрена SPA на React.
- **Infrastructure** — слой технических деталей: настройки БД, очередей, планировщиков задач (Celery), инфраструктурные сервисы (Traefik/Caddy, Docker Compose) и CI/CD.

## Доменные контуры

1. **Weather Forecasting** — сбор данных из разных источников, нормализация и агрегирование в единый формат, управление SLA для провайдеров.
2. **Monitoring & Telemetry** — сбор телеметрии от собственных станций, их регистрация и управление через Core Manager.
3. **Recommendation Engine** — получение пользовательских предпочтений и вызов LLM через OpenRouter для генерации советов.
4. **Notifications** — управление каналами доставки уведомлений (push, email, MQTT) с использованием шаблонов.

Каждый контур представлен в Core соответствующими сервисами и интерфейсами, а также своим набором адаптеров во внешнем слое.

## Потоки данных

1. **Интеграция с провайдерами погоды**: Scheduler Celery инициирует задачи сбора данных → Integration Layer обращается к API провайдеров → данные нормализуются и сохраняются в Core.
2. **Станции наблюдений**: IoT-устройства публикуют сообщения в MQTT → брокер маршрутизирует их в ingestion-сервис → сервис валидирует payload и обновляет состояние станций.
3. **Пользовательские запросы**: Клиент SPA → REST API → Core → адаптеры провайдеров/LLM при необходимости → ответ клиенту.

## CI/CD и качество

- **Проверки качества**: `ruff`, `black`, `isort` и `pytest` запускаются локально через pre-commit и в GitHub Actions (см. `.github/workflows/ci.yml`).
- **Pre-commit**: конфигурация в `.pre-commit-config.yaml` гарантирует единый стиль кода перед отправкой изменений.
- **Версионность зависимостей**: dev-зависимости зафиксированы в `requirements-dev.txt`, что упрощает воспроизводимость CI и локальной разработки.

## План развития

- Автоматизация генерации диаграмм (Mermaid → PNG) в CI.
- Добавление интеграционных тестов для ключевых adapter'ов.
- Введение контрактного тестирования для внешних API с помощью VCR-подобных инструментов.
